---
title: "Functions for LSM Package"
author: "Harpeth Lee"
date: "8/4/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Array to XYZ Function

This function converts the image array into a matrix with xyz coordinates and intensities for 3D images or a matrix with xy coordinates and intensities for 2D images. This function also filters all values from the data frame with an intensity below the `min_intensity` variable.

```{r array to matrix, echo = FALSE, message=FALSE}
## This function converts the image array into a matrix with four columns containing the x, y, and z coordinates of each pixel and the value (intensity) of each pixel. The variable `min_intensity` lets us set a threshold to exclude all points with intensities below that value.

library(dplyr)

array_to_xyz <- function(array) {
  
  array_df <- as.data.frame.table(array)
  
  if(!is.matrix(array)) {
    colnames(array_df) <- c("x", "y", "z", "intensity")
    array_df$z <- as.numeric(array_df$z)
    array_df$z <- array_df$z - 1
  } else {
    colnames(array_df) <- c("x", "y", "intensity")
  }

  array_df$x <- as.numeric(array_df$x)
  array_df$y <- as.numeric(array_df$y)
  
  # Subtract 1 so xyz coords in matrix match those in opened image
  array_df$x <- array_df$x - 1
  array_df$y <- array_df$y - 1

  as.matrix(array_df)
}
```


## Image Cluster Function

Takes an image array or matrix and returns a list of matrices containing points in a graph.

- `max_dist`: Sets a maximum distance, in pixels, that pixels may have from another pixel in the graph to be connected to the graph.
- `min_intensity`: All pixels with values below the intense floor are filtered out and not included in the graph.
- `sample_prop`: Proportion of pixels to remain after sampling to construct the graph, sampling occurs after filtering using `min_intensity`.
- `min_cluster_size`: Minimum number of pixels in cluster/graph to keep in returned list.

These variables will all have a major impact on the returned list. They can be pretty finicky, it may take a bit of time to find values that will return a meaningful final product. When comparing images makes sure to use the same setting in order to compare.

## Find a way to calculate distance for only points within a certain xyz distance, probably filt.

```{r image cluster, echo = FALSE, message=FALSE}
## This function uses the igraph library to create a list containing the indices of all points in a matrix that are connected to another point in the cluster within a distance equal to the value `max_dist`.

library(rlist)
library(igraph)

image_cluster <- function(x, max_dist = 10, min_intensity = 2000, min_cluster_size = 50, sample_prop = 2^(-8), sample_type = "grid") {
  
  if(!is.array(x)) {
    stop("x must be an object of the class array")
  }
  
  if(!(length(dim(x)) %in% c(2,3))) {
    stop("x must be an array with either 2 or 3 dimensions")
  }
  
  # Makes sure sample_prop is a numeric. If it isn't a number between 0 and 1, it sets
  # the prop equal to 0 if the value is negative or 1 if the value is greater than 1.
  if(!is.numeric(sample_prop)) {
    stop("sample_prop must be a numeric")
  } else if(sample_prop > 1) {
    sample_prop = 1
  } else if(sample_prop < 0) {
    sample_prop = 0
  }
  
  if(!is.numeric(max_dist)) {
     stop("max_dist must be a numeric")
  } else if(max_dist <= 0) {
    stop("max_dist must be a positive number")
  }
  
  if(!is.numeric(min_intensity)) {
    stop("min_intensity must be a numeric")
  }
  
  if(!is.numeric(min_cluster_size)) {
    stop("min_cluster_size must be a numeric")
  } else if(min_cluster_size < 0) {
    stop("min_cluster_size must be a positive number")
  }
  
  
  # This saves converts the array to a matrix containing x, y, and, z coordinates along with the pixels value
  # as well as removing all entries with an intensity below the min_intensity
  x <- array_to_xyz(x)
  
  
  if(dim(x)[2] == 4) {
    x <- x[x[, 4] >= min_intensity,]
  } else if(dim(x)[2] == 3) {
    x <- x[x[, 3] >= min_intensity,]
  }
  
  # Takes a sample from the matrix. This allows the igraph function to run or at least run faster.
  # When the sample is too large, there is a chance of the dist() function maxing our R's memory.
  
  if(sample_type %in% c("grid", "g", "Grid", "GRID")) {
    samp <- seq(1, nrow(x), by = 1/sample_prop)
    x <- x[samp, ]
  } else if(sample_type %in% c("random", "r", "Random", "RANDOM")) {
    x <- x[sample(nrow(x), nrow(x)*sample_prop), ]
  } else {
       stop("sample_type takes the values `grid` and `random`")
     }
  
  
  if(dim(x)[1] == 0) {
    stop("min_intensity is too large. No pixels in the image have values above this level.")
  }
  
  # Creates new matrix the doesn't contain the intensity values of pixels
  if(dim(x)[2] == 4) {
    x_alt <- x[, -4]
  } else if(dim(mtrx)[2] == 3) {
    x_alt <- x[, -3]
  }
  
  
  # Creates a matrix containing the distance between points
  dist_x <- as.matrix(dist(x_alt))
  
  
  # Creates vector to store clustered points in.
  clustered_points <- replicate(ncol(dist_x), NULL)
  
  # Finds the indices of all points that are within 10 pixels of each other and saves them as a list
  for(i in 1:ncol(dist_x)) {
    for(j in 1:nrow(dist_x))  {
      if(dist_x[i, j] < max_dist & i != j) {
        clustered_points[[i]] <- c(clustered_points[[i]], j)
      } } }
  
  
  # Using the clustered_points list, these function from the igraph package create the cluster list 
  g = graph_from_adj_list(clustered_points, mode = "all")
  comp = components(g)
  cluster <- igraph::groups(comp)
  
  
  # Changes class of cluster from array to list
  dim(cluster) <- NULL
  
  
  # Removes all clusters below a certain size from list
  cluster <- cluster[lapply(cluster, length) > min_cluster_size]
  
  
  # Turns cluster to list of matrices containing x,y,z coordinates and intensity of pixels in cluster. 
  cluster <- lapply(cluster, function(a) {
    x[a,]
  })
  
  cluster
  
}
```

## Interval Proportion Comparison

```{r}
library(dplyr)

hist_prop_comp <- function(x, y, to = 2^16, by = 2^12) {
  
  break_seq = seq(0, to, by = by)
 
  x_hist <- hist(x, breaks = break_seq, plot = FALSE)
  y_hist <- hist(y, breaks = break_seq, plot = FALSE)
  
  x_props <- x_hist$counts/length(x)
  y_props <- y_hist$counts/length(y)
  
  diff_df <- data.frame(bin = x_hist$breaks[2:length(x_hist$breaks)],
                        diff = abs(x_props - y_props))
  diff_df <- arrange(diff_df, desc(diff))
  diff_df <- head(diff_df, 5)
  
  prop_difference = sum(abs(x_props - y_props))/2
  correlation = cor(x_props, y_props)
  data.frame(prop_difference, correlation)
}
```


## Grid Proportion

This function takes in an image array as an argument and divides it into $\text{grid_dim}^2$ rectangular prisms. Right now, the function only creates a two dimensional grid in order to make results more interpretable.
```{r}
grid_prop <- function(image_array, floor = 1000, grid_dim = c(4,4,4)) {
  
  div_seq_1 <- seq(1, dim(image_array)[1], by = dim(image_array)[1]/grid_dim)
  div_seq_2 <- seq(1, dim(image_array)[2], by = dim(image_array)[2]/grid_dim)
  
  section_prop <- matrix(nrow = grid_dim, ncol = grid_dim)
  
  for(i in 1:grid_dim) {
    for(j in 1:grid_dim) {
      section <- image_array[div_seq_1[i]:(div_seq_1[i] + (dim(image_array)[1]/grid_dim - 1)),
                    div_seq_2[j]:(div_seq_2[j] + (dim(image_array)[2]/grid_dim - 1)), ]
      section_prop[i, j] <- sum(section > floor)/length(section)
    }
  }
  section_prop
}
```


## Crop Function

```{r Crop Function}
## This function crops the two image arrays, removing all matrices from the edges that only contain values lower than the specified value in both arrays.
## Returns a list of two cropped arrays of the same dimensions.

crop_array <- function(image_array_1, image_array_2, value = 0) {
  
  if(!is.array(image_array_1 | !is.array(image_array_2))) {
    stop("image_array must be of class array")
  }
  
  for(i in 1:dim(image_array_1)[1]) {
    if(any(image_array_1[i,,] > value) | any(image_array_2[i,,] > value)) {
      i
      break
    }}
  
  for(j in dim(image_array_1)[1]:1) {
    if(any(image_array_1[j,,] > value) | any(image_array_2[j,,] > value)) {
      j
      break
    }}
  
  for(k in 1:dim(image_array_1)[2]) {
    if(any(image_array_1[,k,] > value) | any(image_array_2[,k,] > value)) {
      k
      break
    }}
  
  for(l in dim(image_array_1)[2]:1) {
    if(any(image_array_1[,l,] > value) | any(image_array_2[,l,] > value)) {
      l
      break
    }}
  
  for(m in 1:dim(image_array_1)[3]) {
    if(any(image_array_1[,,m] > value) | any(image_array_2[,,m] > value)) {
      m
      break
    }}
  
  for(n in dim(image_array_1)[3]:1) {
    if(any(image_array_1[,,n] > value) | any(image_array_2[,,n] > value)) {
      n
      break
    }}
  
  list(image_array_1[i:j, k:l, m:n], image_array_2[i:j, k:l, m:n])
  
  }
```


## Max Plot

```{r max plot function}
library(imager)

max_plot <- function(array) {
  num_rows <- dim(array)[1]
  num_cols <- dim(array)[2]
  num_mtrs <- dim(array)[3]
  
  max_intensity_1 <- matrix(nrow = num_cols, ncol = num_mtrs)
  for(i in 1:num_cols) {
    for(j in 1:num_mtrs) {
      max_intensity_1[i, j] <- max(array[, i, j])
    }
    }
  
  max_intensity_2 <- matrix(nrow = num_rows, ncol = num_cols)
  
  for(i in 1:num_rows) {
    for(j in 1:num_cols) {
      max_intensity_2[i, j] <- max(array[i, j,])
    }
    }
  max_intensity_3 <- matrix(nrow = num_rows, ncol = num_mtrs)
  for(i in 1:num_rows) {
    for(j in 1:num_mtrs) {
      max_intensity_3[i, j] <- max(array[i, , j])
    }
  }
  
  plot(as.cimg(max_intensity_1))
  plot(as.cimg(max_intensity_2))
  plot(as.cimg(max_intensity_3))
}
```